<!DOCTYPE html>
<head>
<meta charset=utf-8>
<title>Detecting HTML 5 Features - Dive Into HTML 5</title>
<link rel=stylesheet href=screen.css>
<style>
body{counter-reset:h1 2}
</style>
<meta name=viewport content="initial-scale=1.0">
</head>
<div id=zz>
<p>You are here: <a href=index.html>Home</a> <span class=u>&#8227;</span> <!--<a href=table-of-contents.html#canvas>-->Dive Into <abbr>HTML</abbr> 5<!--</a>--> <span class=u>&#8227;</span>
<h1>Detecting <abbr>HTML</abbr> 5 Features</h1>
<p id=toc>&nbsp;
<p class=a>&#x2042;
<h2 id=divingin>Diving In</h2>

<p class=f><img src=i/aoc-y.png alt=Y width=106 height=105>ou may well ask: &#8220;How can I start using <abbr>HTML</abbr> 5 if older browsers don&#8217;t support it?&#8221; But the question itself is misleading. <abbr>HTML</abbr> 5 is not one big thing; it is a collection of individual features. So you can&#8217;t detect &#8220;<abbr>HTML</abbr> 5 support,&#8221; because that doesn&#8217;t make any sense. But you <em>can</em> detect support for individual features, like canvas, video, or geolocation.

<p class=a>&#x2042;

<h2 id=techniques>Detection Techniques</h2>

<p>When your browser renders a web page, it constructs a Document Object Model (<abbr>DOM</abbr>), a collection of objects that represent the <abbr>HTML</abbr> elements on the page. Every element&nbsp;&mdash;&nbsp;every <code>&lt;p></code>, every <code>&lt;div></code>, every <code>&lt;span></code>&nbsp;&mdash;&nbsp;is represented in the <abbr>DOM</abbr> by a different object. (There are also global objects, like <code>window</code> and <code>document</code>, that aren&#8217;t tied to specific elements.)

<p class=ss style="width:257px"><img src=i/openclipart.org_johnny_automatic_peeking_out_the_window.png width=257 height=436 alt="girl peeking out the window">

<p>All <abbr>DOM</abbr> objects share a set of common properties, but some objects have more than others. In browsers that support <abbr>HTML</abbr> 5 features, certain objects will have unique properties. A quick peek at the <abbr>DOM</abbr> will tell you which features are supported.

<p>There are four basic techniques for detecting whether a browser supports a particular feature. From simplest to most complex:

<ol>
<li>
<p>Check if a certain property exists on a global object (such as <code>window</code> or <code>navigator</code>).
<p>Example: <a href=#geolocation>testing for geolocation support</a>
<li>
<p>Create an element, then check if a certain property exists on that element.
<p>Example: <a href=#canvas>testing for canvas support</a>
<li>
<p>Create an element, check if a certain method exists on that element, then call the method and check the value it returns.
<p>Example: <a href=#video-formats>testing which video formats are supported</a>
<li>
<p>Create an element, set a property to a certain value, then check if the property retained its value.
<p>Example: <a href=#input-types>testing which <code>&lt;input></code> types are supported</a>
</ol>

<p class=a>&#x2042;

<h2 id=modernizr>Modernizr, the HTML 5 Detection Library</h2>

<p><a href=http://modernizr.com/>Modernizer</a> is an open source (<abbr>MIT</abbr>-licensed) JavaScript library that detects support for several HTML 5 features. To use it, include the following <code>&lt;script></code> element within the <code>&lt;head></code> element at the top of your page.

<pre style="float:left"><code>&lt;!DOCTYPE html>
&lt;html>
&lt;head>
  &lt;meta charset="utf-8">
  &lt;title>Dive Into HTML 5&lt;/title>
  <mark>&lt;script src="modernizr-1.0.min.js"></script></mark>
&lt;/head>
&lt;body>
  ...
&lt;/body>
&lt;/html>
</code></pre>
<p class="legend right" style="margin-top:7.25em"><span class=arrow>&nbsp;&#x219c;</span> It goes to your &lt;head>

<p class=clear>Modernizr runs automatically. There is no <code>modernizr_init()</code> function to call. When it runs, it creates an global object called <code>Modernizr</code>, which contains a set of Boolean properties for each feature it can detect. For example, if your browser supports the <a href=canvas.html>canvas <abbr>API</abbr></a>, the <code>Modernizr.canvas</code> property will be <code>true</code>. If your browser does not support the canvas <abbr>API</abbr>, the <code>Modernizr.canvas</code> property will be <code>false</code>.

<pre><code>if (Modernizr.canvas) {
  // let's draw some shapes!
} else {
  // no native canvas support available :(
}</code></pre>

<p class=a>&#x2042;

<!--
<h2 id=elements>New Semantic Elements</h2>

<p>FIXME

<p class=a>&#x2042;
-->

<h2 id=canvas>Canvas</h2>

<p class=ss style="width:300px"><img src=i/openclipart.org_johnny_automatic_fishing_boat.png width=300 height=203 alt="man fishing in a canoe"><br><span id=live-canvas></span>

<p><abbr>HTML</abbr> 5 defines <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html>the &lt;canvas> element</a> as &#8220;a resolution-dependent bitmap canvas which can be used for rendering graphs, game graphics, or other visual images on the fly.&#8221; A <dfn>canvas</dfn> is a rectangle in your page where you can use JavaScript to draw anything you want. <abbr>HTML</abbr> 5 defines a set of functions (&#8220;the canvas <abbr>API</abbr>&#8221;) for drawing shapes, defining paths, creating gradients, and applying transformations.

<p>Checking for the canvas <abbr>API</abbr> uses <a href=#techniques>detection technique #2</a>. If your browser supports the canvas <abbr>API</abbr>, the <abbr>DOM</abbr> object it creates to represent a <code>&lt;canvas></code> element will have a <a href=canvas.html#shapes><code>getContext()</code> method</a>. If your browser doesn&#8217;t support the canvas <abbr>API</abbr>, the <abbr>DOM</abbr> object it creates for a <code>&lt;canvas></code> element will only have the set of common properties, but not anything canvas-specific.

<pre><code>function supports_canvas() {
  return !!document.createElement('canvas').getContext;
}
</code></pre>

<p>This function starts by creating a dummy <code>&lt;canvas></code> element. But the element is never attached to your page, so no one will ever see it. It&#8217;s just floating in memory, going nowhere and doing nothing, like a canoe on a lazy river.

<pre><code>return !!document.<mark>createElement('canvas')</mark>.getContext;</code></pre>

<p>As soon as you create the dummy <code>&lt;canvas></code> element, you test for the presence of a <code>getContext()</code> method. This method will only exist if your browser supports the canvas <abbr>API</abbr>.

<pre><code>return !!document.createElement('canvas').<mark>getContext</mark>;</code></pre>

<p>Finally, you use the double-negative trick to force the result to a Boolean value (<code>true</code> or <code>false</code>).

<pre><code>return <mark>!!</mark>document.createElement('canvas').getContext;</code></pre>

<p>This function will detect support for most of the canvas <abbr>API</abbr>, including <a href=canvas.html#shapes>shapes</a>, <a href=canvas.html#paths>paths</a>, <a href=canvas.html#gradients>gradients <i class=baa>&amp;</i> patterns</a>. It will not detect the third-party <a href=canvas.html#ie><code>explorercanvas</code> library</a> that implements the canvas <abbr>API</abbr> in Microsoft Internet Explorer.

<p>Instead of writing this function yourself, you can use <a href=#modernizr>Modernizr</a> to detect support for the canvas <abbr>API</abbr>.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> check for canvas support
<pre><code>if (<mark>Modernizr.canvas</mark>) {
  // let's draw some shapes!
} else {
  // no native canvas support available :(
}</code></pre>

<p>There is a separate test for the canvas text <abbr>API</abbr>, which I will demonstrate next.

<p class=a>&#x2042;

<h2 id=canvas-text>Canvas Text</h2>

<p class=ss style="width:414px"><img src=i/openclipart.org_johnny_automatic_baseball_at_bat.png width=414 height=254 alt="baseball player at bat"><br><span id=live-canvas-text></span>

<p>Even if your browser supports the <a href=#canvas>canvas <abbr>API</abbr></a>, it might not support the canvas text <abbr>API</abbr>. The canvas <abbr>API</abbr> grew over time, and the text functions were added late in the game. Some browsers shipped with canvas support before the text <abbr>API</abbr> was complete.

<p>Checking for the canvas text <abbr>API</abbr> uses <a href=#techniques>detection technique #2</a>. If your browser supports the canvas <abbr>API</abbr>, the <abbr>DOM</abbr> object it creates to represent a <code>&lt;canvas></code> element will have the <a href=canvas.html#shapes><code>getContext()</code> method</a>. If your browser doesn&#8217;t support the canvas <abbr>API</abbr>, the <abbr>DOM</abbr> object it creates for a <code>&lt;canvas></code> element will only have the set of common properties, but not anything canvas-specific.

<pre><code>function supports_canvas_text() {
  if (!supports_canvas()) { return false; }
  var dummy_canvas = document.createElement('canvas');
  var context = dummy_canvas.getContext('2d');
  return (typeof context.fillText == 'function');
}</code></pre>

<p>The function starts by <a href=#canvas>checking for canvas support</a>, using the <code>supports_canvas()</code> function you just saw in the previous section. If your browser doesn&#8217;t support the canvas <abbr>API</abbr>, it certainly won&#8217;t support the canvas text <abbr>API</abbr>!

<pre><code>if (<mark>!supports_canvas()</mark>) { return false; }
  var dummy_canvas = document.createElement('canvas');
  var context = dummy_canvas.getContext('2d');
  return (typeof context.fillText == 'function');</code></pre>

<p>Next, you create a dummy <code>&lt;canvas></code> element and get its drawing context. This is guaranteed to work, because the <code>supports_canvas()</code> function already checked that the <code>getContext()</code> method exists on all canvas objects.

<pre><code>if (!supports_canvas()) { return false; }
  var dummy_canvas = document.createElement('canvas');
  var context = <mark>dummy_canvas.getContext('2d')</mark>;
  return (typeof context.fillText == 'function');</code></pre>

<p>Finally, you check whether the drawing context has a <code>fillText()</code> function. If it does, the canvas text <abbr>API</abbr> is available. Hooray!

<pre><code>if (!supports_canvas()) { return false; }
  var dummy_canvas = document.createElement('canvas');
  var context = dummy_canvas.getContext('2d');
  return (<mark>typeof context.fillText == 'function'</mark>);</code></pre>

<p>Instead of writing this function yourself, you can use <a href=#modernizr>Modernizr</a> to detect support for the canvas text <abbr>API</abbr>.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> check for canvas text support
<pre><code>if (<mark>Modernizr.canvastext</mark>) {
  // let's draw some text!
} else {
  // no native canvas text support available :(
}</code></pre>

<p class=a>&#x2042;

<h2 id=video>Video</h2>

<p><abbr>HTML</abbr> 5 defines a new element called <code>&lt;video></code> for embedding video in your web pages. Embedding video used to be impossible without third-party plugins such as Apple QuickTime&reg; or Adobe Flash&reg;.

<p class=ss style="width:224px"><img src=i/openclipart.org_johnny_automatic_at_the_theater.png alt="audience at the theater" width=224 height=334><br><span id=live-video></span>

<p>The <code>&lt;video></code> element is designed to be usable without any detection script at all. You can specify multiple video files, and browsers that support <abbr>HTML</abbr> 5 video will choose one based on what video formats they support. (See &#8220;A gentle introduction to video encoding&#8221; <a href=http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats>part 1: container formats</a> and <a href=http://diveintomark.org/archives/2008/12/19/give-part-2-lossy-video-codecs>part 2: lossy video codecs</a> to learn about different video formats.)

<p>Browsers that don&#8217;t support <abbr>HTML</abbr> 5 video will ignore the <code>&lt;video></code> element completely, but you can use this to your advantage and tell them to play video through a third-party plugin instead. Kroc Camen has designed a solution called <a href=http://camendesign.com/code/video_for_everybody>Video for Everybody!</a> which uses <abbr>HTML</abbr> 5 video where available, but falls back to Apple QuickTime&reg; or Adobe Flash&reg; in older browsers. This solution uses no JavaScript whatsoever, and it works in virtually every browser, including mobile browsers. I&#8217;ll explain more about this solution in the video chapter, whenever I get around to writing it.

<p>If you want to do more with video than plop it on your page and play it, you&#8217;ll need to use JavaScript. Checking for video support uses <a href=#techniques>detection technique #2</a>. If your browser supports <abbr>HTML</abbr> 5 video, the <abbr>DOM</abbr> object it creates to represent a <code>&lt;video></code> element will have a <code>canPlayType()</code> method. If your browser doesn&#8217;t support <abbr>HTML</abbr> 5 video, the <abbr>DOM</abbr> object it creates for a <code>&lt;video></code> element will only have the set of properties common to all elements.

<pre><code>function supports_video() {
  return !!document.createElement('video').canPlayType;
}</code></pre>

<p>Instead of writing this function yourself, you can use <a href=#modernizr>Modernizr</a> to detect support for <abbr>HTML</abbr> 5 video.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> check for <abbr>HTML</abbr> 5 video support
<pre><code>if (<mark>Modernizr.video</mark>) {
  // let's play some video!
} else {
  // no native video support available :(
  // maybe check for QuickTime&reg; or Flash&reg; instead
}</code></pre>

<p>There is a separate test for detecting which video formats your browser can play, which I will demonstrate next.

<p class=a>&#x2042;

<h2 id=video-formats>Video Formats</h2>

<p>Video formats are like written languages. An English newspaper conveys the same information as a Spanish newspaper, but if you can only read English, only one of them is going to be useful to you! To play a video, your browser needs to understand the &#8220;language&#8221; in which the video was written.

<p class=ss style="float:left;margin:0 1.75em 1.75em 0;width:250px"><img src=i/openclipart.org_johnny_automatic_man_reading_newspaper.png alt="man reading newspaper" width=250 height=261><br><span id=live-video-formats></span>

<p>The &#8220;language&#8221; of a video is called a &#8220;codec&#8221;&nbsp;&mdash;&nbsp;the algorithm used to encode the video into a stream of bits. There are dozens of codecs in use all over the world. Which one should you use? The unfortunate reality of <abbr>HTML</abbr> 5 video is that browsers can&#8217;t agree on a single codec. However, they seem to have narrowed it down to two. One codec costs money (because of patent licensing), but it works in <a href=http://www.apple.com/safari/>Safari</a> and on the iPhone.  (This one also works in Adobe Flash&reg;, if you use a solution like <a href=http://camendesign.com/code/video_for_everybody>Video for Everybody!</a>) The other codec is free and works in open source browsers like <a href=http://code.google.com/chromium/>Chromium</a> and <a href=http://www.getfirefox.com/>Mozilla Firefox</a>.

<p>Checking for video format support uses <a href=#techniques>detection technique #3</a>. If your browser supports <abbr>HTML</abbr> 5 video, the <abbr>DOM</abbr> object it creates to represent a <code>&lt;video></code> element will have a <code>canPlayType()</code> method. This method will tell you whether the browser supports a particular video format.

<p>This function checks for the patent-encumbered format supported by Macs and iPhones.

<pre><code>function supports_h264_baseline_video() {
  if (!supports_video()) { return false; }
  var v = document.createElement("video");
  return v.canPlayType('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
}</code></pre>

<p>The function starts by <a href=#video>checking for <abbr>HTML</abbr> 5 video support</a>, using the <code>supports_video()</code> function you just saw in the previous section. If your browser doesn&#8217;t support <abbr>HTML</abbr> 5 video, it certainly won&#8217;t support any video formats!

<pre><code>function supports_h264_baseline_video() {
  if (<mark>!supports_video()</mark>) { return false; }
  var v = document.createElement("video");
  return v.canPlayType('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
}</code></pre>

<p>Then the function creates a dummy video element (but doesn&#8217;t attach it to the page, so it won&#8217;t be visible) and calls the <code>canPlayType()</code> method. This method is guaranteed to be there, because the <code>supports_video()</code> function just checked for it.

<pre><code>function supports_h264_baseline_video() {
  if (!supports_video()) { return false; }
  var <mark>v</mark> = document.createElement("video");
  return <mark>v.canPlayType</mark>('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
}</code></pre>

<p>A &#8220;video format&#8221; is really a combination of several different things. In technical terms, you&#8217;re asking the browser whether it can play H.264 Baseline video and AAC LC audio in an MPEG-4 container. (I&#8217;ll explain what all that means when I write the video chapter. Until then, you can read <a href=http://diveintomark.org/tag/give>A gentle introduction to video encoding</a>.)

<pre><code>function supports_h264_baseline_video() {
  if (!supports_video()) { return false; }
  var v = document.createElement("video");
  return v.canPlayType('<mark>video/mp4; codecs="avc1.42E01E, mp4a.40.2"</mark>');
}</code></pre>

<p>The <code>canPlayType()</code> function doesn&#8217;t return <code>true</code> or <code>false</code>. In recognition of how complex video formats are, the function returns a string:

<ul>
<li><code>"probably"</code> if the browser is fairly confident it can play this format
<li><code>"maybe"</code> if the browser thinks it might be able to play this format
<li><code>""</code> (an empty string) if the browser is certain it can&#8217;t play this format
</ul>

<p>This second function checks for the open video format supported by Mozilla Firefox and other open source browsers. The process is exactly the same; the only difference is the string you pass in to the <code>canPlayType()</code> function. In technical terms, you&#8217;re asking the browser whether it can play Theora video and Vorbis audio in an Ogg container.

<pre><code>function supports_ogg_theora_video() {
  if (!supports_video()) { return false; }
  var v = document.createElement("video");
  return v.canPlayType(<mark>'video/ogg; codecs="theora, vorbis"'</mark>);
}</code></pre>

<p><a href=#modernizr>Modernizr</a> can&#8217;t yet detect individual video formats, so you&#8217;ll need to use the functions listed here.

<p class=a>&#x2042;

<h2 id=storage>Local Storage</h2>

<p class=ss style="width:135px"><img src=i/openclipart.org_johnny_automatic_half_stack_of_horizontal_sections.png alt="filing cabinet with drawers of different sizes" width=135 height=341><br><span id=live-storage></span>

<p><a href=http://dev.w3.org/html5/webstorage/><abbr>HTML</abbr> 5 storage</a> provides a way for web sites to store information on your computer and retrieve it later. The concept is similar to cookies, but it&#8217;s designed for larger quantities of information. Cookies are limited in size, and your browser sends them back to the web server every time it requests a new page (which takes extra time and precious bandwidth). <abbr>HTML</abbr> 5 storage stays on your computer, and web sites can access it with JavaScript after the page is loaded.

<blockquote class=note>
<p><span>&#x261E;</span>Q: How secure is my <abbr>HTML</abbr> 5 storage database? Can anyone read it?<br>
A: Anyone who has physical access to your computer can probably look at (or even change) your <abbr>HTML</abbr> 5 storage database. Within your browser, any web site can read and modify its own values, but sites can&#8217;t access values stored by other sites. This is called a <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#origin-0>same-origin restriction</a>.
</blockquote>

<p>Checking for <abbr>HTML</abbr> 5 storage support uses <a href=#techniques>detection technique #1</a>. If your browser supports <abbr>HTML</abbr> 5 storage, there will be a <code>localStorage</code> property on the global <code>window</code> object. If your browser doesn&#8217;t support <abbr>HTML</abbr> 5 storage, the <code>localStorage</code> property will be undefined.

<pre><code>function supports_local_storage() {
  return !!(typeof window.localStorage != 'undefined');
}</code></pre>

<p><a href=#modernizr>Modernizr</a> can&#8217;t yet detect support for <abbr>HTML</abbr> 5 storage, so you&#8217;ll need to use the function listed here.

<p class=a>&#x2042;

<h2 id=offline>Offline Web Applications</h2>

<p class=ss style="width:257px"><img src=i/openclipart.org_johnny_automatic_cabin_along_stream.png alt="cabin in the woods" width=257 height=242><br><span id=live-offline></span>

<p>Reading static web pages offline is easy: connect to the Internet, load a web page, disconnect from the Internet, drive to a cabin in the woods, and read the web page as your leisure. (To save time, you may wish to skip the step about the cabin.) But what about web applications like <a href=http://mail.google.com/>Gmail</a> or <a href=http://docs.google.com/>Google Docs</a>? Thanks to <abbr>HTML</abbr> 5, anyone (not just Google!) can build a web application that works offline.

<p><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html#offline>Offline web applications</a> start out as online web applications. The first time you visit an offline-enabled web site, the web server tells your browser which files it needs in order to work offline. These files can be anything&nbsp;&mdash;&nbsp;<abbr>HTML</abbr>, JavaScript, images, even <a href=#video>videos</a>. Once your browser downloads all the necessary files, you can revisit the web site even if you&#8217;re not connected to the Internet. Your browser will notice that you&#8217;re offline and use the files it already downloaded. Once you get back online, any changes you made can be uploaded to the remote web server.

<p>Checking for offline support uses <a href=#techniques>detection technique #1</a>. If your browser supports offline web applications, there will be an <code>applicationCache</code> property on the global <code>window</code> object. If your browser doesn&#8217;t support offline web applications, the <code>applicationCache</code> property will be undefined.

<pre><code>function supports_offline() {
  return !!(typeof window.applicationCache != 'undefined');
}</code></pre>

<p><a href=#modernizr>Modernizr</a> can&#8217;t yet detect support for offline web applications, so you&#8217;ll need to use the function listed here.

<p class=a>&#x2042;

<h2 id=geolocation>Geolocation</h2>

<p id=live-geolocation></p>

<p>FIXME-intro

<p>FIXME-detection technique #1

<p>If your browser supports the geolocation <abbr>API</abbr>, the global <code>navigator</code> object will have a property called <code>geolocation</code>.

<pre><code>function supports_geolocation() {
  return !!navigator.geolocation;
}</code></pre>

<p>FIXME-explanation

<p>FIXME-Modernizr alternative

<p class=a>&#x2042;

<h2 id=input-types>Input Types</h2>

<p>FIXME-intro

<p>FIXME-detection technique #4

<pre><code>function supported_input_types() {
  var input_type = {};
  var all_input_types = 
    ['search', 'tel', 'url', 'email', 'datetime',
     'date', 'month', 'week', 'time', 'datetime-local',
     'number', 'range', 'color'];
  for (var index = all_input_types.length - 1; index >= 0; index--) {
    var itype = all_input_types[index];
    i.setAttribute("type", itype);
    input_type[itype] = !!(i.type !== "text");
  }
  return input_type;
}</code></pre>

<p>FIXME-Modernizr alternative

<p class=a>&#x2042;

<h2 id=input-placeholder>&lt;input placeholder></h2>

<p>FIXME-intro

<p>FIXME-detection technique #2

<pre><code>function supports_input_placeholder() {
  var i = document.createElement('input');
  return !!('placeholder' in i);
}</code></pre>

<p>FIXME-no Modernizr support yet

<p class=a>&#x2042;

<h2 id=input-autofocus>&lt;input autofocus></h2>

<p>FIXME-intro

<p>FIXME-detection technique #2

<pre><code>function supports_input_autofocus() {
  var i = document.createElement('input');
  return !!('autofocus' in i);
}</code></pre>

<p>FIXME-no Modernizr support yet

<p class=a>&#x2042;

<h2 id=input-required>&lt;input required></h2>

<p>FIXME-intro

<p>FIXME-detection technique #2

<pre><code>function supports_input_required() {
  var i = document.createElement('input');
  return !!('required' in i);
}</code></pre>

<p>FIXME-no Modernizr support yet

<p class=a>&#x2042;

<!--
<h2 id=input-autocomplete>&lt;input autocomplete></h2>

<p>FIXME

<p class=a>&#x2042;
-->

<h2 id=input-pattern>&lt;input pattern></h2>

<p>FIXME-intro

<p>FIXME-detection technique #2

<pre><code>function supports_input_pattern() {
  var i = document.createElement('input');
  return !!('pattern' in i);
}</code></pre>

<p>FIXME-no Modernizr support yet

<p class=a>&#x2042;

<p class=c>Copyright MMIX O&#8217;Reilly Media &bull; written by <a href=about.html>Mark Pilgrim</a>

<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:6jgee_nxreo><input type=hidden name=ie value=UTF-8><input type=search name=q size=25>&nbsp;<input type=submit name=sa value=Search></div></form>
</div>
<script src=j/jquery.js></script>
<script src=j/modernizr.js></script>
<script src=j/gears_init.js></script>
<script src=j/geo.js></script>
<script src=j/dih5.js></script>
<script>
function supports(bool, suffix) {
  var s = "Your browser ";
  if (bool) {
    s += "supports " + suffix + ".";
  } else {
    s += "does not support " + suffix + ". :(";
  }
  return s;
}
function I_CAN_HAS(result) {
  if (result == "probably") {
    return "can play";
  }
  if (result == "maybe") {
    return "isn't sure if it can play";
  }
  return "can't play";
}
$(document).ready(function() {
  $("#live-canvas").html(supports(Modernizr.canvas, "the canvas API"));
  $("#live-canvas-text").html(supports(Modernizr.canvas, "the canvas text API"));
  $("#live-video").html(supports(Modernizr.video, "HTML 5 video"));
  if (Modernizr.video) {
    var v = document.createElement("video");
    var ogg = v.canPlayType('video/ogg; codecs="theora, vorbis"');
    var mp4 = v.canPlayType('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
    var vf = "Your browser ";
    if ((ogg == "probably") && (mp4 == "probably")) {
      vf += "can play both Ogg Theora and H.264";
    } else if (((ogg == "") || (ogg == "no")) && (mp4 == "probably")) {
      vf += "can play H.264 video, but not Ogg Theora";
    } else if (((mp4 == "") || (mp4 == "no")) && (ogg == "probably")) {
      vf += "can play Ogg Theora video, but not H.264";
    } else {
      vf += I_CAN_HAS(ogg) + " Ogg Theora video. Your browser " + I_CAN_HAS(mp4) + " H.264";
    }
    $("#live-video-formats").html(vf + " video.");
  } else {
    $("#live-video-formats").html(supports(Modernizr.video, "any video formats"));
  }
  $("#live-storage").html(supports(!!(typeof window.localStorage != 'undefined'), "HTML 5 storage"));
  $("#live-offline").html(supports(!!(typeof window.applicationCache != 'undefined'), "offline web applications"));
  $("#live-geolocation").html(supports(geo_position_js.init(), "geolocation"));
});
</script>
